<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Live Seismic (Band-pass + Envelope)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/global.css') }}" />
</head>
<body>
  {% include "navbar.html" %}
  <div id="wrap">
    <div id="mapWrap" class="container-main">
      <div id="map"></div>
      <div id="badges" class="overlay dark"></div>
      <div id="legend" class="overlay dark"></div>
    </div>
    <div id="waveWrap" class="container-section">
      <div id="wave"></div>
    </div>
  </div>

<script>
/* ------------ Color scale (normalized 0..1, 10 bins) ------------ */
const BINS=10, RED='#ff1744';
const SCALE10=['#440154','#482878','#3e4a89','#31688e','#26828e','#1f9e89','#35b779','#6ece58','#b5de2b','#fde725'];
const lastSnapById = {};   // id -> latest socket payload for that station

const colorForNorm = v => (!Number.isFinite(v) || v<0 || v>1) ? RED : SCALE10[Math.min(BINS-1, Math.max(0, Math.floor(v*BINS)))];
const fmt = v => Number.isFinite(v) ? v.toFixed(1) : '—';
const fmtPct = v => Number.isFinite(v) ? (v*100).toFixed(0)+'%' : '—';

/* ------------------------------ Map ------------------------------ */
const map=L.map('map',{preferCanvas:true});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OpenStreetMap'}).addTo(map);
map.setView([-31.35,115.92],10);
requestAnimationFrame(()=>map.invalidateSize());
window.addEventListener('resize', ()=>map.invalidateSize());

const stationLayer=L.layerGroup().addTo(map), markers={};
let firstFit=false, openId=null;

function ensureMarker(s){
  if (markers[s.id]) return markers[s.id];
  const circle=L.circle([s.lat,s.lon],{radius:1000,color:'#222',weight:2,fillColor:colorForNorm(s.norm),fillOpacity:0.75});
  const dot=L.circleMarker([s.lat,s.lon],{radius:6,color:'#000',fillColor:'#000',fillOpacity:1,weight:1});
  const tip=L.tooltip({permanent:true,direction:'top',offset:[0,-8],className:'rmsTip'})
              .setContent(`${s.id}<br/>env ${fmt(s.env_series?.at(-1))} (norm ${fmtPct(s.norm)})`);
  dot.bindTooltip(tip).openTooltip();
  const group=L.layerGroup([circle,dot]).addTo(stationLayer);
  circle.on('click',()=>loadWaveform(s.id)); dot.on('click',()=>loadWaveform(s.id));
  return (markers[s.id]={group,circle,dot,tip});
}
function upsertMarker(s){
  const m=markers[s.id]||ensureMarker(s), ll=L.latLng(s.lat,s.lon);
  m.circle.setLatLng(ll); m.dot.setLatLng(ll);
  m.circle.setStyle({fillColor:colorForNorm(s.norm)});
  m.tip.setContent(`${s.id}<br/>env ${fmt(s.env_series?.at(-1))} (norm ${fmtPct(s.norm)})`);
}

/* ----------------------------- Legend ---------------------------- */
(function renderLegend(){
  const box=document.getElementById('legend');
  let html='<h4>Envelope (normalized 0–1)</h4>';
  for(let i=0;i<SCALE10.length;i++){
    html+=`<div class="row"><span class="sw" style="background:${SCALE10[i]}"></span><span>${(i/BINS).toFixed(1)}–${((i+1)/BINS).toFixed(1)}</span></div>`;
  }
  html+=`<div class="note"><b style="color:${RED}">Red</b> = out of range / missing</div>`;
  box.innerHTML=html;
})();

function updateBadges(stations){
  const root=document.getElementById('badges'); root.innerHTML='';
  stations.forEach(s=>{
    const span=document.createElement('span');
    span.className='badge';
    span.style.borderColor=span.style.color=colorForNorm(s.norm);
    span.textContent=`${s.id}: env ${fmt(s.env_series?.at(-1))} (norm ${fmtPct(s.norm)})`;
    span.onclick=()=>loadWaveform(s.id);
    root.appendChild(span);
  });
}

/* ---------------------------- Waveform --------------------------- */
async function loadWaveform(id){ openId=id; await drawWave(true); }

async function drawWave(force=false){
  if (!openId) return;
  const snap=lastSnapById[openId];
  if (snap && Array.isArray(snap.band) && snap.band.length){
    const fs=Number(snap.env_fs||5), tEnd=snap.timestamp?new Date(snap.timestamp).getTime():Date.now();
    const mkXs = (arr)=>arr.map((_,i)=>new Date(tEnd - (arr.length-1-i)*1000/fs));
    const bandXs=mkXs(snap.band);
    const traces=[{x:bandXs,y:snap.band,type:'scatter',mode:'lines',name:'Band-pass (0.05–0.10 Hz)',line:{width:1.6}}];
    if (snap.env_series?.length){
      traces.push({x:mkXs(snap.env_series),y:snap.env_series,type:'scatter',mode:'lines',name:'Envelope',yaxis:'y2',line:{width:2}});
    }
    Plotly.react('wave',traces,{
      paper_bgcolor:'#111',plot_bgcolor:'#111',font:{color:'#eaeaea'},
      margin:{l:50,r:10,t:10,b:40},
      xaxis:{title:'time',gridcolor:'#333'},
      yaxis:{title:'band-pass',gridcolor:'#333'},
      yaxis2:{overlaying:'y',side:'right',title:'envelope',showgrid:false,zeroline:false},
      legend:{orientation:'h',x:0,y:1.12},uirevision:'keep'
    },{responsive:true});
    return;
  }
  // No data yet — clear
  Plotly.react('wave',[],{
    paper_bgcolor:'#111',plot_bgcolor:'#111',font:{color:'#eaeaea'},
    margin:{l:50,r:10,t:10,b:40},
    xaxis:{title:'time',gridcolor:'#333'},
    yaxis:{title:'band-pass',gridcolor:'#333'},uirevision:'keep'
  },{responsive:true});
}

/* ----------------------------- Socket ---------------------------- */
const socket=io();
socket.on("station_update",(payload)=>{
  const stations=Array.isArray(payload?.stations)?payload.stations:[];
  stations.forEach(s=>{
    if (!Number.isFinite(s.lat)||!Number.isFinite(s.lon)) return;
    upsertMarker(s);
    lastSnapById[s.id]=s;
  });

  if (!firstFit && stations.length){
    const b=L.latLngBounds(stations.map(s=>[s.lat,s.lon]));
    if (b.isValid()) map.fitBounds(b,{padding:[30,30],maxZoom:12});
    firstFit=true;
    loadWaveform(stations[0].id);
  }
  updateBadges(stations);
});
setInterval(()=>drawWave(false),1000);
</script>
</body>
</html>
