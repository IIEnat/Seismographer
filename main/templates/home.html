<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Live Seismic (Band-pass + Envelope)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/global.css') }}" />
</head>
<body>
  {% include "navbar.html" %}

  <div id="wrap" class="with-panel">
    <!-- MAP -->
    <div id="mapWrap" class="container-main">
      <div id="map"></div>

      <!-- startup overlay -->
      <div id="startupOverlay" class="overlay-startup">
        <div id="startupBox" class="overlay-startup__box"></div>
      </div>
    </div>

    <!-- SIDE PANEL -->
    <aside id="sidePanel">
      <section class="panel-section">
        <h3 class="panel-title">Stations</h3>
        <div id="badgeList" class="panel-chips"></div>
      </section>

      <section class="panel-section">
        <h3 class="panel-title">Info</h3>
        <div class="panel-kv"><span>Network</span><b>GG</b></div>
        <div class="panel-kv"><span>Streaming</span><b>250 Hz raw</b></div>
        <div class="panel-kv"><span>Processed</span><b>5 Hz</b></div>
        <div class="panel-kv"><span>Selected</span><b id="selectedSta">—</b></div>
      </section>

      <section class="panel-section">
        <h3 class="panel-title">Legend (Envelope 0–1)</h3>
        <div id="legendBins"></div>
        <div class="panel-note"><b style="color:#ff1744">Red</b> = out of range / missing</div>
      </section>
    </aside>
  </div>

  <!-- WAVEFORM -->
  <div id="waveWrap" class="container-section">
    <div id="wave"></div>
  </div>

  <script>
    /* ==================== constants ==================== */
    const BINS = 10, RED = '#ff1744';
    const SCALE10 = ['#440154','#482878','#3e4a89','#31688e','#26828e','#1f9e89','#35b779','#6ece58','#b5de2b','#fde725'];

    // countdown defaults from server, but pure-frontend
    const DEFAULT_STARTUP = Number('{{ STARTUP_SECONDS|default(30) }}') || 30;

    // FE seam handling
    const UI_FS = 5;                         // 5 Hz series from backend
    const TAIL_WINDOW_S = 40;               // redraw tail length
    const FORCED_RECONCILE_EVERY_S = 2;     // how often to re-smooth the tail
    const FORCED_FULL_REDRAW_EVERY_S = 40;  // belt & suspenders

    /* ==================== helpers ==================== */
    const colorForNorm = v =>
      (!Number.isFinite(v) || v < 0 || v > 1)
        ? RED
        : SCALE10[Math.min(BINS-1, Math.max(0, Math.floor(v*BINS)))];

    const fmt = v => Number.isFinite(v) ? v.toFixed(1) : '—';
    const fmtPct = v => Number.isFinite(v) ? (v*100).toFixed(0)+'%' : '—';

    /* ==================== map ==================== */
    const map = L.map('map', { preferCanvas:true });
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { maxZoom:19, attribution:'© OpenStreetMap' }).addTo(map);
    map.setView([-31.35,115.92],10);
    requestAnimationFrame(()=>map.invalidateSize());
    window.addEventListener('resize', ()=>map.invalidateSize());

    const stationLayer = L.layerGroup().addTo(map), markers = {};
    function ensureMarker(s){
      if (markers[s.id]) return markers[s.id];
      const circle = L.circle([s.lat,s.lon], {
        radius:1000, color:'#222', weight:2, fillColor:colorForNorm(s.norm), fillOpacity:0.75
      });
      const dot = L.circleMarker([s.lat,s.lon], { radius:6, color:'#000', fillColor:'#000', fillOpacity:1, weight:1 });
      const tip = L.tooltip({ permanent:true, direction:'top', offset:[0,-8], className:'rmsTip' })
        .setContent(`${s.id}<br/>env ${fmt(s.env_series?.at(-1))} (norm ${fmtPct(s.norm)})`);
      dot.bindTooltip(tip).openTooltip();
      const group = L.layerGroup([circle,dot]).addTo(stationLayer);
      circle.on('click',()=>loadWaveform(s.id)); dot.on('click',()=>loadWaveform(s.id));
      return (markers[s.id] = {group,circle,dot,tip});
    }
    function upsertMarker(s){
      const m = markers[s.id] || ensureMarker(s);
      const ll = L.latLng(s.lat,s.lon);
      m.circle.setLatLng(ll); m.dot.setLatLng(ll);
      m.circle.setStyle({ fillColor: colorForNorm(s.norm) });
      m.tip.setContent(`${s.id}<br/>env ${fmt(s.env_series?.at(-1))} (norm ${fmtPct(s.norm)})`);
    }

    /* ==================== side panel ==================== */
    (function renderLegend(){
      const root = document.getElementById('legendBins');
      root.innerHTML = '';
      for (let i=0;i<SCALE10.length;i++){
        const row = document.createElement('div');
        row.className='legend-row';
        row.innerHTML = `<span class="sw" style="background:${SCALE10[i]}"></span>
                         <span>${(i/BINS).toFixed(1)}–${((i+1)/BINS).toFixed(1)}</span>`;
        root.appendChild(row);
      }
    })();

    function updateBadges(stations){
      const wrap = document.getElementById('badgeList');
      wrap.innerHTML = '';
      stations.forEach(s=>{
        const chip = document.createElement('button');
        chip.className='chip';
        const c = colorForNorm(s.norm);
        chip.style.borderColor = chip.style.color = c;
        chip.textContent = `${s.id} — env ${fmt(s.env_series?.at(-1))}`;
        chip.onclick = ()=>loadWaveform(s.id);
        wrap.appendChild(chip);
      });
    }

    /* ==================== waveform + FE tail fix ==================== */
    const lastSnapById = {};
    let openId = null, firstFit = false;

    function loadWaveform(id){ openId = id; document.getElementById('selectedSta').textContent = id; drawWave(true); }

    // FE: recompute the last TAIL_WINDOW_S of envelope using the last 5 Hz band
    function reconcileTailFE(snap){
      if (!snap || !Array.isArray(snap.band) || !snap.band.length) return;
      const band = snap.band.slice();                       // 5 Hz band
      const env  = Array.isArray(snap.env_series) ? snap.env_series.slice() : [];
      if (!env.length) return;

      const tailPts = Math.max(1, Math.round(TAIL_WINDOW_S * UI_FS));
      const end = env.length - 1;
      const start = Math.max(0, end - tailPts - Math.round(3*UI_FS)); // a bit of context

      // 1) peak pick (very light) on |band|
      const ab = band.map(Math.abs);
      const minDist = Math.max(1, Math.round(2 * UI_FS));             // ~2s separation
      const peaks = [];
      for (let i=Math.max(1,start+1); i<end-1; i++){
        if (ab[i] >= ab[i-1] && ab[i] >= ab[i+1]){
          if (peaks.length===0 || (i - peaks[peaks.length-1]) >= minDist) peaks.push(i);
        }
      }
      if (peaks[0] !== start) peaks.unshift(start);
      if (peaks[peaks.length-1] !== end) peaks.push(end);

      // 2) piecewise-linear envelope through peaks (PCHIP-like but cheap/safe)
      const envNew = env.slice(); // copy
      for (let k=0;k<peaks.length-1;k++){
        const i0 = peaks[k],  i1 = peaks[k+1];
        const y0 = ab[i0],    y1 = ab[i1];
        const span = i1 - i0 || 1;
        for (let j=i0;j<=i1;j++){
          const t = (j - i0)/span;
          envNew[j] = (1-t)*y0 + t*y1;   // linear interp
        }
      }

      // 3) splice back only the part we touched
      for (let i=start;i<=end;i++) env[i] = envNew[i];

      snap.env_series = env;                            // replace in current snapshot
      snap._fePatchedEpoch = (snap._fePatchedEpoch||0) + 1;
    }

    function drawWave(force=false){
      if (!openId) return;
      const snap = lastSnapById[openId];
      if (!snap || !Array.isArray(snap.band) || !snap.band.length){
        Plotly.react('wave', [], {
          paper_bgcolor:'#111', plot_bgcolor:'#111', font:{color:'#eaeaea'},
          margin:{l:50,r:10,t:10,b:40}, xaxis:{gridcolor:'#333'}, yaxis:{gridcolor:'#333'}
        }, {responsive:true});
        return;
      }

      // force FE reconciliation of the tail on each draw (cheap at 5 Hz)
      reconcileTailFE(snap);

      const fs = Number(snap.env_fs || UI_FS);
      const tEnd = snap.timestamp ? new Date(snap.timestamp).getTime() : Date.now();
      const mkXs = arr => arr.map((_,i)=>new Date(tEnd - (arr.length-1-i)*1000/fs));

      const traces = [{
        x: mkXs(snap.band), y: snap.band,
        type:'scatter', mode:'lines', name:'Band-pass (0.05–0.10 Hz)', line:{width:1.6}
      }];
      if (snap.env_series?.length){
        traces.push({ x: mkXs(snap.env_series), y: snap.env_series, type:'scatter', mode:'lines', name:'Envelope', line:{width:2} });
      }

      Plotly.react('wave', traces, {
        paper_bgcolor:'#111', plot_bgcolor:'#111', font:{color:'#eaeaea'},
        margin:{l:50,r:10,t:10,b:40},
        xaxis:{title:'time',gridcolor:'#333'},
        yaxis:{title:'band-pass / envelope',gridcolor:'#333'},
        legend:{orientation:'h',x:0,y:1.12},
        uirevision:'keep'
      }, {responsive:true});
    }

    /* ==================== startup overlay ==================== */
    let startupSecCfg = DEFAULT_STARTUP, startupStartMs = null, startupTargetMs = null, startupTimerId=null;
    const startupOverlay = document.getElementById('startupOverlay');
    const startupBox     = document.getElementById('startupBox');

    function startStartupCountdown(sec){
      startupSecCfg = Number(sec) || DEFAULT_STARTUP;
      if (startupStartMs == null) {
        startupStartMs  = Date.now();
        startupTargetMs = startupStartMs + startupSecCfg*1000;
      }
      renderStartupBox();
      if (startupTimerId == null) startupTimerId = setInterval(renderStartupBox, 250);
    }
    function renderStartupBox(){
      const now = Date.now();
      const remainingMs  = Math.max(0, (startupTargetMs ?? now) - now);
      const remainingSec = Math.ceil(remainingMs / 1000);
      startupBox.innerHTML =
        `<b>Preparing the first ${startupSecCfg}s for accurate curves…</b><br/>
         Display will begin automatically once ready.<br/>
         <span class="text-muted">Remaining: ${remainingSec}s</span>`;
      if (remainingMs <= 0) {
        startupOverlay.style.display = 'none';
        clearInterval(startupTimerId); startupTimerId = null;
      }
    }

    /* ==================== socket wiring ==================== */
    const socket = io();
    socket.on("station_update",(payload)=>{
      const stations = Array.isArray(payload?.stations) ? payload.stations : [];

      // start countdown on first payload
      if (stations.length && startupStartMs == null) {
        const sec = Number(stations[0]?.startup_seconds);
        startStartupCountdown(Number.isFinite(sec) ? sec : DEFAULT_STARTUP);
      }

      stations.forEach(s=>{
        if (!Number.isFinite(s.lat) || !Number.isFinite(s.lon)) return;
        upsertMarker(s);
        lastSnapById[s.id] = s;
      });

      if (!firstFit && stations.length){
        const b = L.latLngBounds(stations.map(s=>[s.lat,s.lon]));
        if (b.isValid()) map.fitBounds(b,{padding:[30,30],maxZoom:12});
        firstFit = true;
        openId = stations[0].id;
        document.getElementById('selectedSta').textContent = openId;
        drawWave(true);
      }

      updateBadges(stations);
    });

    // keep the curve moving
    setInterval(()=>drawWave(false), 1000);

    // FE tail reconciliation every few seconds
    setInterval(()=>{ if (openId && lastSnapById[openId]) { reconcileTailFE(lastSnapById[openId]); drawWave(true); } }, FORCED_RECONCILE_EVERY_S*1000);

    // full redraw safety net
    setInterval(()=>drawWave(true), FORCED_FULL_REDRAW_EVERY_S*1000);
  </script>
</body>
</html>
