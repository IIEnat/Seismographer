<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Realtime Seismic Map — Mock-up 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <link rel="stylesheet" href="{{ url_for('static', filename='css/global_mock1.css') }}" />
</head>
<body>
  <header>
    <h1>Realtime Seismic Map</h1>
    <span class="sep">|</span>
    <div class="chip">Polling: <span id="pollMs">1000</span> ms</div>
    <label>Interval:
      <select id="pollSelect">
        <option value="250">250 ms</option>
        <option value="500">500 ms</option>
        <option value="1000" selected>1000 ms</option>
        <option value="2000">2000 ms</option>
        <option value="5000">5000 ms</option>
      </select>
    </label>
    <span class="sep">|</span>
    <div class="chip chip--muted">APIs: <code>/live</code> · <code>/wave</code></div>
    <div class="chip chip--muted">Click a station to load waveform</div>

    <span class="sep">|</span>
    <div id="quickNav">
      <a class="btn btn--outline" href="/">Home</a>
      <a class="btn btn--outline" href="/manual">Manual</a>
      <a class="btn btn--outline" href="/beamforming">Beamforming</a>
    </div>
  </header>

  <div id="wrap">
    <div id="topRow">
      <div id="mapWrap" class="container-main">
        <div id="map"></div>
      </div>

      <!-- Docked panel -->
      <div id="menuPanel" class="panel">
        <div class="section">
          <h3>View</h3>
          <div class="tabs">
            <button id="tabGrid" class="tab active" type="button">Grid View</button>
            <button id="tabStation" class="tab" type="button">Station View</button>
          </div>
          <div class="help text-muted">Grid = map focus. Station = per-station detail.</div>
        </div>

        <div class="section">
          <h3>SOH</h3>
          <div id="sohList"></div>
        </div>

        <div class="section">
          <h3>Info</h3>
          <div class="text-xs text-muted">
            Network: <span id="netName">—</span><br/>
            Sample rate: <span id="sampleRate">—</span> Hz<br/>
            Selected station: <span id="selStation">—</span>
          </div>
        </div>

        <div class="section">
          <h3>Streaming</h3>
          <select id="pollSelectMirror">
            <option value="250">250 ms</option>
            <option value="500">500 ms</option>
            <option value="1000" selected>1000 ms</option>
            <option value="2000">2000 ms</option>
            <option value="5000">5000 ms</option>
          </select>
        </div>

        <div class="section">
          <h3>Scale</h3>
          <select id="scaleSelect">
            <option value="linear" selected>Linear</option>
            <option value="log">Logarithmic</option>
          </select>
        </div>

        <div class="section" id="legendBox">
          <h3>Legend</h3>
          <div id="legendContent"></div>
        </div>
      </div>
    </div>

    <!-- Bottom: Z (60%) + X/Y stacked (40%) with scale strip -->
    <div id="waveWrap" class="container-section">
      <!-- Scale strip (UI-only) -->
      <div class="scale-strip">
        <span class="lbl">Scale</span>
        <input class="scale-slider" type="range" min="0" max="1" step="1" value="0" />
        <div class="ticks"><span>Linear</span><span>Log</span></div>
      </div>

      <div class="graphsRow">
        <div id="zCol">
          <div class="graphBox" id="wave"></div>
        </div>
        <div id="xyCol">
          <div class="graphBox" id="waveX"></div>
          <div class="graphBox" id="waveY"></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* --- shared config & helpers (scale-aware color, legend) --- */
const LIVE_URL = `/live`;
const WAVE_URL = `/wave`;
let POLL_MS = 1000, scaleMode='linear';
const LEVELS=[100,300,500,800,1200], LOG_LEVELS=LEVELS.map(v=>Math.log10(v));
const COLORS5=[{name:'Red',hex:'#e31a1c'},{name:'Green',hex:'#33a02c'},{name:'Blue',hex:'#1f78b4'},{name:'Yellow',hex:'#ffcc00'},{name:'Orange',hex:'#ff7f00'}];
const CIRCLE_RADIUS_M=1000;
const stationOrder={}; let stationSeq=0;
const isNum=v=>Number.isFinite(v)&&!Number.isNaN(v);
const nearestIndex=(v,a)=>a.reduce((b,_,i)=>Math.abs(v-a[i])<Math.abs(v-a[b])?i:b,0);
function getStationOffset(id){ if(!(id in stationOrder)) stationOrder[id]=stationSeq++; return stationOrder[id]%COLORS5.length; }
function rmsLevelIndex(rms){ const v=Math.max(1e-9,rms||0); return (scaleMode==='log')?nearestIndex(Math.log10(v),LOG_LEVELS):nearestIndex(v,LEVELS); }
function colorForStationRMS(id,rms){ const idx=rmsLevelIndex(rms),off=getStationOffset(id); return COLORS5[(idx+off)%COLORS5.length]; }
function renderLegend(){
  const box=document.getElementById('legendContent');
  let html='<div class="text-xs">';
  for(let i=0;i<COLORS5.length;i++){
    const label=(scaleMode==='log')?`log₁₀≈${LOG_LEVELS[i].toFixed(2)}`:`~${LEVELS[i]}`;
    html+=`<div class="row"><span class="sw" style="background:${COLORS5[i].hex}"></span><span style="font-size:12px;">${COLORS5[i].name} → ${label}</span></div>`;
  }
  html+='<div class="note">Color bins adapt to the selected scale.</div></div>';
  box.innerHTML=html;
}

/* map */
const map=L.map('map',{preferCanvas:true});
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19,attribution:'© OpenStreetMap'}).addTo(map);
map.setView([0,0],2); requestAnimationFrame(()=>map.invalidateSize());
const stationLayer=L.layerGroup().addTo(map); const markers={}; let firstFit=false;

function ensureMarker(s,lat,lon){
  if(markers[s.id]) return markers[s.id];
  const circle=L.circle([lat,lon],{radius:CIRCLE_RADIUS_M,color:'#222',weight:2,fillColor:colorForStationRMS(s.id,s.rms).hex,fillOpacity:.6});
  const m=L.circleMarker([lat,lon],{radius:6,color:'#000',fillColor:'#000',fillOpacity:1,weight:1});
  const tip=L.tooltip({permanent:true,direction:'top',offset:[0,-8],className:'rmsTip'}).setContent(`${s.id}<br/>RMS ${Number(s.rms||0).toFixed(1)}`);
  m.bindTooltip(tip).openTooltip();
  const group=L.layerGroup([circle,m]).addTo(stationLayer);
  const onClick=()=>loadWaveform(s.id); circle.on('click',onClick); m.on('click',onClick);
  return (markers[s.id]={group,circle,marker:m,tip});
}
function upsertMarker(s,lat,lon){
  const entry=markers[s.id]||ensureMarker(s,lat,lon), ll=L.latLng(lat,lon);
  entry.circle.setLatLng(ll); entry.marker.setLatLng(ll);
  entry.circle.setStyle({fillColor:colorForStationRMS(s.id,s.rms).hex});
  entry.tip.setContent(`${s.id}<br/>RMS ${Number(s.rms||0).toFixed(1)}`);
}

/* poll /live */
async function poll(){
  try{
    const res=await fetch(LIVE_URL,{cache:'no-store'}); if(!res.ok) return;
    const payload=await res.json();
    let stations=Array.isArray(payload.stations)?payload.stations:[];
    stations=stations.map(s=>({...s,lat:Number(s.lat),lon:Number(s.lon)})).filter(s=>isNum(s.lat)&&isNum(s.lon));
    const groups=new Map(), key=s=>`${s.lat.toFixed(6)},${s.lon.toFixed(6)}`;
    stations.forEach(s=>{const k=key(s); if(!groups.has(k)) groups.set(k,[]); groups.get(k).push(s.id)});
    const renderPos=new Map(); for(const [k,ids] of groups.entries()){
      const [lat,lon]=k.split(',').map(Number), n=ids.length; if(n===1){renderPos.set(ids[0],[lat,lon]); continue;}
      const Rm=140; for(let i=0;i<n;i++){const ang=(2*Math.PI*i)/n, dx=Rm*Math.cos(ang), dy=Rm*Math.sin(ang); renderPos.set(ids[i], offsetLatLng(lat,lon,dx,dy));}
    }
    for(const s of stations){ const pos=renderPos.get(s.id)||[s.lat,s.lon]; upsertMarker(s,pos[0],pos[1]); }
    const seen=new Set(stations.map(s=>s.id));
    Object.keys(markers).forEach(id=>{ if(!seen.has(id)){ stationLayer.removeLayer(markers[id].group); delete markers[id]; }});
    if(!firstFit && stations.length){
      const bounds=L.latLngBounds(stations.map(s=>renderPos.get(s.id)||[s.lat,s.lon]));
      if(bounds.isValid()) map.fitBounds(bounds,{padding:[30,30],maxZoom:12});
      firstFit=true; loadWaveform(stations[0].id);
    }
    document.getElementById('pollMs').textContent=POLL_MS;
    updateSOH(stations);
  }catch{}
}
function offsetLatLng(lat,lon,dx,dy){ const R=6378137; const dLat=(dy/R)*180/Math.PI; const dLon=(dx/(R*Math.cos(lat*Math.PI/180)))*180/Math.PI; return [lat+dLat, lon+dLon]; }
let pollTimer=null; function startPolling(){ if(pollTimer) clearInterval(pollTimer); pollTimer=setInterval(poll,POLL_MS); poll(); }
document.getElementById('pollSelect').addEventListener('change',e=>{POLL_MS=parseInt(e.target.value,10); startPolling();});

/* axis-id helper: reuse BH? siblings (no app.py change needed) */
const AXIS_LETTER = { X: 'E', Y: 'N', Z: 'Z' };
function idWithAxis(baseId, axis) {
  const letter = AXIS_LETTER[axis] || 'Z';
  return baseId.replace(/(.*\.BH)[ENZ]$/i, `$1${letter}`);
}

/* wave drawing (Z, X, Y) */
let openId=null, lastSecKeyZ=null, wavePollBackoff=1000;
async function loadWaveform(id){
  openId=id; lastSecKeyZ=null; wavePollBackoff=1000; selStationEl.textContent=id||'—';
  await drawWaveZ(true); await drawWaveAxis('X','waveX',true); await drawWaveAxis('Y','waveY',true);
}
async function drawWaveZ(force=false){ await drawWaveAxis('Z','wave',force,true); }
async function drawWaveAxis(axis, elemId, force=false, isZ=false){
  if(!openId) return;
  try{
    const idToFetch = idWithAxis(openId, axis);
    const res=await fetch(`${WAVE_URL}?id=${encodeURIComponent(idToFetch)}`,{cache:'no-store'});
    if(res.status===404){ setTimeout(()=>drawWaveAxis(axis,elemId,false,isZ), Math.min(wavePollBackoff*=1.5,5000)); return; }
    if(!res.ok) return;
    const data=await res.json();
    if(isZ && !force && lastSecKeyZ===data.sec_key) return;
    if(isZ) lastSecKeyZ=data.sec_key;

    const fs=data.fs||0, values=Array.isArray(data.values)?data.values:[], dt=fs>0?(1.0/fs):0.004;
    const t0=new Date(data.t0_iso); const xs=new Array(values.length);
    for(let i=0;i<values.length;i++) xs[i]=new Date(t0.getTime()+i*dt*1000);

    Plotly.react(elemId,[{x:xs,y:values,type:'scatter',mode:'lines',name:`${axis}`}],
      {paper_bgcolor:'#111',plot_bgcolor:'#111',font:{color:'#eaeaea'},
       margin:{l:50,r:10,t:10,b:40},
       xaxis:{title:'time',gridcolor:'#333'},
       yaxis:{title:'amplitude',gridcolor:'#333',type:scaleMode},
       uirevision:'keep'}, {responsive:true});
    if(isZ && fs) document.getElementById('sampleRate').textContent=fs;
    wavePollBackoff=1000;
  }catch{}
}
setInterval(()=>{ drawWaveZ(false); drawWaveAxis('X','waveX',false); drawWaveAxis('Y','waveY',false); },1000);

/* kick */
startPolling();

/* panel glue */
const tabGridBtn=document.getElementById('tabGrid'), tabStationBtn=document.getElementById('tabStation');
function setView(mode){ if(mode==='grid'){tabGridBtn.classList.add('active'); tabStationBtn.classList.remove('active');} else {tabStationBtn.classList.add('active'); tabGridBtn.classList.remove('active');} }
tabGridBtn.addEventListener('click',()=>setView('grid')); tabStationBtn.addEventListener('click',()=>setView('station'));
const pollSelectHeader=document.getElementById('pollSelect'), pollSelectMirror=document.getElementById('pollSelectMirror');
function syncPoll(from,to){ to.value=from.value; } syncPoll(pollSelectHeader,pollSelectMirror);
pollSelectMirror.addEventListener('change',e=>{pollSelectHeader.value=e.target.value; pollSelectHeader.dispatchEvent(new Event('change'));});
pollSelectHeader.addEventListener('change',()=>syncPoll(pollSelectHeader,pollSelectMirror));
const sohList=document.getElementById('sohList'); function updateSOH(stations){ sohList.innerHTML=''; for(const s of stations){ const chip=document.createElement('span'); chip.className='chip'; chip.textContent=s.id; chip.onclick=()=>loadWaveform(s.id); sohList.appendChild(chip);} }
const selStationEl=document.getElementById('selStation');

/* scale (functional dropdown in panel) */
const scaleSelect=document.getElementById('scaleSelect');
scaleSelect.addEventListener('change',e=>{ scaleMode=e.target.value; renderLegend(); drawWaveZ(true); drawWaveAxis('X','waveX',true); drawWaveAxis('Y','waveY',true); });
renderLegend();
</script>
</body>
</html>