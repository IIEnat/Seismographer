<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Seismographer Playback</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/global.css') }}" />
</head>
<body>
    <header>
        <h1>Playback</h1>
        <a href="/" class="chip">Go to Live</a>
        <span class="sep">|</span>
        <span class="chip chip--muted">Upload .mseed / .miniseed to view content</span>
    </header>

    <!-- Upload Form -->
    <div class="container">
        <form id="uploadForm" enctype="multipart/form-data" method="POST" style="margin: .75rem 0 1rem;">
            <input type="file" name="seedlink_file" id="seedlink_files" accept=".mseed,.seed,.dat,.miniseed" multiple required>
            <button id="uploadAndPlayBtn" type="submit" class="btn btn--primary">Upload & Play</button>
        </form>
    </div>

    <div id="wrap" class="with-panel">
        <!-- MAP -->
        <div id="mapWrap" class="container-main">
            <div id="seismicMap"></div>
            
            <!-- Query result overlay -->
            <div id="queryResult" class="overlay dark" style="right: 10px; top: 10px; left: auto; display: none;"></div>
        </div>

        <!-- SIDE PANEL -->
        <aside id="sidePanel">
            <section class="panel-section">
                <h3 class="panel-title">Stations</h3>
                <div id="badgeList" class="panel-chips"></div>
            </section>

            <section class="panel-section">
                <h3 class="panel-title">Playback Info</h3>
                <div class="panel-kv"><span>Files</span><b id="fileCount">—</b></div>
                <div class="panel-kv"><span>Timeline</span><b id="timelineInfo">—</b></div>
                <div class="panel-kv"><span>Selected</span><b id="selectedStation">—</b></div>
                <div class="panel-kv"><span>Playing</span><b id="playingStatus">Stopped</b></div>
            </section>

            <section class="panel-section">
                <h3 class="panel-title">Legend</h3>
                <div id="legendBins"></div>
                <div class="panel-note"><b style="color:#ff1744">Red</b> = out of range / missing</div>
            </section>
        </aside>
    </div>

    <!-- CONTROLS -->
    <div class="container">
        <div id="controls">
            <div class="controls-row">
                <button id="playBtn" type="button" class="btn" disabled>▶ Play</button>
                <button id="pauseBtn" type="button" class="btn" disabled>⏸ Pause</button>
                <select id="stationSelect" class="station-select" hidden></select>
                <span id="sliderLabel" class="text-xs text-muted"></span>
            </div>

            <div class="slider-container">
                <label for="playbackSlider" class="slider-caption">Timeline:</label>
                <input type="range" id="playbackSlider" class="slider" min="0" max="0" value="0" disabled>
            </div>
        </div>
    </div>

    <!-- WAVEFORM -->
    <div id="waveWrap" class="container-section">
        <div id="wave"></div>
    </div>

    <script>
        let RMS_MIN = 30000, RMS_MAX = 40000;
        const BINS = 10;
        const RED_OOR = '#ff1744';
        const SCALE10 = ['#440154', '#482878', '#3e4a89', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde725'];

        function setColorRange(minV, maxV) {
            if (Number.isFinite(minV) && Number.isFinite(maxV) && minV < maxV) {
                RMS_MIN = minV;
                RMS_MAX = maxV;
                renderLegend();
                refreshMap();
            }
        }

        function colorForRMS_10(rms) {
            if (!Number.isFinite(rms)) return RED_OOR;
            if (rms < RMS_MIN || rms > RMS_MAX) return RED_OOR;
            const t = (rms - RMS_MIN) / (RMS_MAX - RMS_MIN);
            const idx = Math.min(BINS - 1, Math.max(0, Math.floor(t * BINS)));
            return SCALE10[idx];
        }

        function fmtAWST(x) {
            const d = (x instanceof Date) ? x : new Date(x);
            const parts = new Intl.DateTimeFormat("en-AU", {
                timeZone: "Australia/Perth",
                year: "numeric", month: "2-digit", day: "2-digit",
                hour: "2-digit", minute: "2-digit", second: "2-digit",
                hour12: false
            }).formatToParts(d).reduce((acc, p) => { acc[p.type] = p.value; return acc; }, {});
            return `${parts.year}-${parts.month}-${parts.day} ${parts.hour}:${parts.minute}:${parts.second} AWST`;
        }

        let uploadedFilenames = [], sliderMin = 0, sliderMax = 0, sliderStartISO = null, sliderEndISO = null,
            selectedStationId = null, playTimer = null;
        const slider = document.getElementById('playbackSlider'),
              sliderLabel = document.getElementById('sliderLabel'),
              playBtn = document.getElementById('playBtn'),
              pauseBtn = document.getElementById('pauseBtn'),
              stationSelect = document.getElementById('stationSelect');

        // Initialize legend
        function renderLegend() {
            const root = document.getElementById('legendBins');
            root.innerHTML = '';
            for (let i = 0; i < SCALE10.length; i++) {
                const row = document.createElement('div');
                row.className = 'legend-row';
                const lo = RMS_MIN + i * (RMS_MAX - RMS_MIN) / BINS;
                const hi = RMS_MIN + (i + 1) * (RMS_MAX - RMS_MIN) / BINS;
                row.innerHTML = `<span class="sw" style="background:${SCALE10[i]}"></span>
                                <span>${lo.toFixed(1)}–${hi.toFixed(1)}</span>`;
                root.appendChild(row);
            }
        }

        function updateBadges(stations) {
            const wrap = document.getElementById('badgeList');
            wrap.innerHTML = '';
            stations.forEach(s => {
                const chip = document.createElement('button');
                chip.className = 'chip';
                const c = colorForRMS_10(s.rms);
                chip.style.borderColor = chip.style.color = c;
                chip.textContent = `${s.id} — ${s.rms.toFixed(1)}`;
                chip.onclick = () => {
                    selectedStationId = s.id;
                    stationSelect.value = s.id;
                    document.getElementById('selectedStation').textContent = s.id;
                    drawWave();
                };
                wrap.appendChild(chip);
            });
        }

        function updateSidePanelInfo() {
            document.getElementById('fileCount').textContent = uploadedFilenames.length || '—';
            if (sliderStartISO && sliderEndISO) {
                const start = new Date(sliderStartISO);
                const end = new Date(sliderEndISO);
                const duration = Math.round((end - start) / 1000 / 60); // minutes
                document.getElementById('timelineInfo').textContent = `${duration}min`;
            }
            document.getElementById('selectedStation').textContent = selectedStationId || '—';
        }

        document.getElementById('uploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const filesInput = document.getElementById('seedlink_files');
            const formData = new FormData();
            for (let i = 0; i < filesInput.files.length; i++) {
                formData.append('seedlink_file', filesInput.files[i]);
            }

            // Upload
            const res = await fetch('/playback', { method: 'POST', body: formData });
            const data = await res.json().catch(() => ({}));
            if (data.status !== 'uploaded') { alert('Upload failed'); return; }

            uploadedFilenames = Array.isArray(data.filenames)
                ? data.filenames
                : [data.filename].filter(Boolean);

            // Prepare timeline
            await initTimeline();

            // Show query result overlay
            const q = document.getElementById('queryResult');
            q.style.display = 'block';

            // ---- Verify the new station JSON shape (timestamp, band/env lengths & values) ----
            try {
                const json = await fetchJSON(`/playback_json/${uploadedFilenames.join(',')}`);
                const n = Array.isArray(json?.stations) ? json.stations.length : 0;
                q.innerHTML = `<b>Files:</b> ${uploadedFilenames.join(', ')}<br/>
                            <b>playback_json:</b> ${n} station object(s) received`;
                console.log('playback_json sample:', json);
            } catch (err) {
                q.innerHTML = 'playback_json fetch failed';
            }

            // ---- Detect hour min/max RMS to seed the color scale (optional) ----
            try {
                const stats = await fetchJSON(`/playback_stats/${uploadedFilenames.join(',')}`);
                const vmin = stats?.min?.value, vmax = stats?.max?.value;
                if (Number.isFinite(vmin) && Number.isFinite(vmax) && vmax > vmin) {
                    q.innerHTML += `<br/><b>Detected Hour RMS Range</b><br/>
                        Min: ${vmin.toFixed(1)} @ <code>${stats.min.id}</code> (${fmtAWST(stats.min.iso)})<br/>
                        Max: ${vmax.toFixed(1)} @ <code>${stats.max.id}</code> (${fmtAWST(stats.max.iso)})`;
                    const ok = window.confirm(
                        `Detected hour min/max RMS:\n\nmin = ${vmin.toFixed(1)}\nmax = ${vmax.toFixed(1)}\n\nUse this as the 10-bin color range?`
                    );
                    if (ok) setColorRange(vmin, vmax);
                } else {
                    q.innerHTML += '<br/>Could not detect min/max RMS';
                }
            } catch {
                q.innerHTML += '<br/>Stats error';
            }

            // Initial render
            await refreshMap();
            await drawWave();
            setPlayingState(false);
            updateSidePanelInfo();
            renderLegend();
        });

        async function initTimeline() {
            const res = await fetch(`/playback_timeline/${uploadedFilenames.join(',')}`, { cache: 'no-store' });
            const t = await res.json();
            sliderStartISO = t.start_iso;
            sliderEndISO = t.end_iso;
            sliderMin = 0;
            sliderMax = Math.max(0, (t.steps ?? 1) - 1);
            slider.min = sliderMin;
            slider.max = sliderMax;
            slider.value = sliderMin;
            slider.disabled = false;
            updateSliderLabel();
            updateSidePanelInfo();
        }

        slider.addEventListener('input', async () => {
            updateSliderLabel();
            await refreshMap();
            await drawWave();
        });

        function updateSliderLabel() {
            if (!sliderStartISO || !sliderEndISO) { sliderLabel.textContent = ''; return; }
            const curISO = getSliderISO(Number(slider.value));
            sliderLabel.textContent = `${fmtAWST(sliderStartISO)} — ${fmtAWST(sliderEndISO)} | Current: ${fmtAWST(curISO)}`;
        }

        function getSliderISO(val) {
            const start = new Date(sliderStartISO).getTime();
            const end = new Date(sliderEndISO).getTime();
            const step = (end - start) / (sliderMax - sliderMin || 1);
            return new Date(start + (val - sliderMin) * step).toISOString();
        }

        let map = null, markers = [];
        function ensureMap() {
            if (map) return;
            map = L.map('seismicMap', { preferCanvas: true }).setView([-31.35, 115.92], 10);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { maxZoom: 18, attribution: '© OpenStreetMap' }).addTo(map);
            requestAnimationFrame(() => map.invalidateSize());
            window.addEventListener('resize', () => map.invalidateSize());
        }

        function populateStationSelect(stations) {
            if (!stations || stations.length <= 1) { stationSelect.hidden = true; stationSelect.replaceChildren(); return; }
            stationSelect.hidden = false;
            stationSelect.replaceChildren(...stations.map(st => {
                const opt = document.createElement('option');
                opt.value = st.id;
                opt.textContent = st.id;
                return opt;
            }));
            if (!selectedStationId) selectedStationId = stations[0].id;
            stationSelect.value = selectedStationId;
            document.getElementById('selectedStation').textContent = selectedStationId;
        }

        async function refreshMap() {
            if (!uploadedFilenames.length) return;
            ensureMap();
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            const step = Number(slider.value);
            const data = await fetchJSON(`/playback_data/${uploadedFilenames.join(',')}/${step}`);
            const stations = Array.isArray(data.stations) ? data.stations : [];
            if (!selectedStationId && stations.length) selectedStationId = stations[0].id;
            populateStationSelect(stations);
            updateBadges(stations);

            stations.forEach(st => {
                const col = colorForRMS_10(st.rms);
                const circle = L.circle([st.lat, st.lon], {
                    radius: 1000, color: '#222', weight: 2, fillColor: col, fillOpacity: 0.75
                });
                const dot = L.circleMarker([st.lat, st.lon], { 
                    radius: 6, color: '#000', fillColor: '#000', fillOpacity: 1, weight: 1 
                });
                const tip = L.tooltip({ permanent: true, direction: 'top', offset: [0, -8], className: 'rmsTip' })
                    .setContent(`${st.id}<br/>RMS ${st.rms.toFixed(1)}`);
                dot.bindTooltip(tip).openTooltip();
                
                const group = L.layerGroup([circle, dot]).addTo(map);
                
                circle.on('click', async () => {
                    selectedStationId = st.id;
                    stationSelect.value = st.id;
                    document.getElementById('selectedStation').textContent = st.id;
                    await drawWave();
                });
                dot.on('click', async () => {
                    selectedStationId = st.id;
                    stationSelect.value = st.id;
                    document.getElementById('selectedStation').textContent = st.id;
                    await drawWave();
                });
                markers.push(group);
            });

            // Fit bounds on first load if not already done
            if (stations.length && !map._fitBoundsDone) {
                const bounds = L.latLngBounds(stations.map(s => [s.lat, s.lon]));
                if (bounds.isValid()) map.fitBounds(bounds, { padding: [30, 30], maxZoom: 12 });
                map._fitBoundsDone = true;
            }
        }

        stationSelect.addEventListener('change', async () => {
            selectedStationId = stationSelect.value;
            document.getElementById('selectedStation').textContent = selectedStationId;
            await drawWave();
        });

        async function drawWave() {
            if (!uploadedFilenames.length || !selectedStationId) {
                Plotly.react('wave', [], {
                    paper_bgcolor: '#111', plot_bgcolor: '#111', font: { color: '#eaeaea' },
                    margin: { l: 50, r: 10, t: 10, b: 40 },
                    xaxis: { gridcolor: '#333' }, yaxis: { gridcolor: '#333' }
                }, { responsive: true });
                return;
            }
            
            const step = Number(slider.value);
            const url = `/playback_wave/${uploadedFilenames.join(',')}/${step}/${encodeURIComponent(selectedStationId)}`;
            const w = await fetchJSON(url);
            const fs = Number(w.fs || 0);
            const values = Array.isArray(w.values) ? w.values : [];
            const t0 = w.t0_iso ? new Date(w.t0_iso) : null;
            
            if (!values.length) {
                Plotly.react('wave', [], {
                    paper_bgcolor: '#111', plot_bgcolor: '#111', font: { color: '#eaeaea' },
                    margin: { l: 50, r: 10, t: 10, b: 40 },
                    xaxis: { gridcolor: '#333' }, yaxis: { gridcolor: '#333' }
                }, { responsive: true });
                return;
            }
            
            const dt = fs > 0 ? 1.0 / fs : 0.004;
            const xs = t0 ? values.map((_, i) => new Date(t0.getTime() + i * dt * 1000)) : values.map((_, i) => i);
            
            Plotly.react('wave', [{
                x: xs,
                y: values,
                type: 'scatter',
                mode: 'lines',
                name: selectedStationId
            }], {
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#eaeaea' },
                margin: { l: 50, r: 10, t: 10, b: 40 },
                xaxis: { title: 'time', gridcolor: '#333' },
                yaxis: { title: 'amplitude', gridcolor: '#333' },
                uirevision: 'keep'
            }, { responsive: true });
        }

        function setPlayingState(isPlaying) {
            playBtn.disabled = isPlaying || slider.disabled;
            pauseBtn.disabled = !isPlaying || slider.disabled;
            document.getElementById('playingStatus').textContent = isPlaying ? 'Playing' : 'Stopped';
        }

        async function stepOnce() {
            const next = Math.min(Number(slider.max), Number(slider.value) + 1);
            slider.value = next;
            updateSliderLabel();
            await refreshMap();
            await drawWave();
            if (next >= Number(slider.max)) stopPlaying();
        }

        function startPlaying(intervalMs = 1000) {
            if (playTimer || slider.disabled) return;
            setPlayingState(true);
            playTimer = setInterval(stepOnce, intervalMs);
        }

        function stopPlaying() {
            if (playTimer) clearInterval(playTimer);
            playTimer = null;
            setPlayingState(false);
        }

        playBtn.addEventListener('click', () => startPlaying(1000));
        pauseBtn.addEventListener('click', stopPlaying);

        async function fetchJSON(url) {
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error('Request failed');
            return res.json();
        }

        // Initialize legend on page load
        renderLegend();
    </script>
</body>
</html>