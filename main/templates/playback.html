<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Seismographer Playback</title>
    <link rel="stylesheet" href="/static/css/global.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        body { background: #0f0f0f; color: #eaeaea; }
        .container { max-width: 1100px; margin: auto; padding: 1.5rem; }
        #seismicMap { width: 100%; height: 100%; background: #1a1a1a; }
        header { display: flex; align-items: center; gap: .5rem; flex-wrap: wrap; margin-bottom: .75rem; }
        .chip { display: inline-block; border: 1px solid #444; border-radius: 999px; padding: .25rem .6rem; font-size: .9rem; }
        .chip--muted { opacity: .75; }
        .sep { opacity: .5; }
        .overlay.dark { color: #ddd; }
        
        /* Layout modifications for side panel */
        #wrap {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 12px;
            width: min(1200px, 92vw);
            margin-inline: auto;
            padding: 12px;
            min-height: 520px;
        }
        
        #mapWrap { position: relative; min-height: 340px; }
        
        /* Side panel styling to match home.html */
        #sidePanel {
            background: #111; 
            border: 1px solid #222; 
            border-radius: 12px; 
            padding: 12px;
            box-shadow: 0 4px 18px rgba(0,0,0,.2); 
            height: 100%; 
            overflow: auto;
        }
        
        .panel-section { margin-bottom: 14px; }
        .panel-title { font-size: 14px; margin: 0 0 8px; font-weight: 700; }
        .panel-kv { display: flex; justify-content: space-between; font-size: 12px; margin: 4px 0; }
        .panel-chips { display: flex; flex-wrap: wrap; gap: 6px; }
        .panel-note { font-size: 11px; opacity: .8; margin-top: 6px; }
        .legend-row { display: flex; align-items: center; gap: 8px; margin: 4px 0; font-size: 12px; }
        .legend-row .sw { width: 14px; height: 14px; border-radius: 3px; border: 1px solid rgba(0,0,0,.25); }
        
        /* Responsive */
        @media (max-width: 800px) {
            #wrap { grid-template-columns: 1fr; }
            #sidePanel { height: auto; }
        }
    </style>
</head>
<body>
    <header>
        <h1>Playback</h1>
        <a href="/" class="chip chip--link">Go to Live</a>
        <span class="sep">|</span>
        <span class="chip chip--muted">Upload .mseed / .miniseed to view content</span>
    </header>

    <div class="container">
        <form id="uploadForm" enctype="multipart/form-data" method="POST" style="margin: .75rem 0 1rem;">
            <input type="file" name="seedlink_file" id="seedlink_files" accept=".mseed,.seed,.dat,.miniseed" multiple required>
            <button id="uploadAndPlayBtn" type="submit" class="btn btn--primary">Upload & Play</button>
        </form>

        <div id="wrap">
            <!-- MAP -->
            <div id="mapWrap" class="container-main">
                <div id="seismicMap"></div>
                <div id="queryResult" class="overlay dark" style="right: 10px; top: 10px; left: auto;"></div>
            </div>

            <!-- SIDE PANEL -->
            <aside id="sidePanel">
                <section class="panel-section">
                    <h3 class="panel-title">Stations</h3>
                    <div id="badgeList" class="panel-chips"></div>
                </section>

                <section class="panel-section">
                    <h3 class="panel-title">Playback Info</h3>
                    <div class="panel-kv"><span>Files</span><b id="fileCount">—</b></div>
                    <div class="panel-kv"><span>Timeline</span><b id="timelineInfo">—</b></div>
                    <div class="panel-kv"><span>Selected</span><b id="selectedStation">—</b></div>
                    <div class="panel-kv"><span>Playing</span><b id="playingStatus">Stopped</b></div>
                </section>

                <section class="panel-section">
                    <h3 class="panel-title">Legend (RMS)</h3>
                    <div id="legendBins"></div>
                    <div class="panel-note"><b style="color:#ff1744">Red</b> = out of range / missing</div>
                </section>
            </aside>
        </div>

        <!-- CONTROLS -->
        <div id="controls">
            <div class="controls-row">
                <button id="playBtn" type="button" class="btn" disabled>▶ Play</button>
                <button id="pauseBtn" type="button" class="btn" disabled>⏸ Pause</button>
                <select id="stationSelect" class="station-select" hidden></select>
                <span id="sliderLabel" class="text-xs text-muted"></span>
            </div>

            <div class="slider-container">
                <label for="playbackSlider" class="slider-caption">Timeline:</label>
                <input type="range" id="playbackSlider" class="slider" min="0" max="0" value="0" disabled>
            </div>
        </div>

        <!-- WAVEFORM -->
        <div id="waveWrap" class="container-section">
            <div id="wave"></div>
        </div>
    </div>

    <script>
        let RMS_MIN = 30000, RMS_MAX = 40000;
        const BINS = 10;
        const RED_OOR = '#ff1744';
        const SCALE10 = ['#440154', '#482878', '#3e4a89', '#31688e', '#26828e', '#1f9e89', '#35b779', '#6ece58', '#b5de2b', '#fde725'];

        function setColorRange(minV, maxV) {
            if (Number.isFinite(minV) && Number.isFinite(maxV) && minV < maxV) {
                RMS_MIN = minV;
                RMS_MAX = maxV;
                renderLegend();
                refreshMap();
            }
        }

        function colorForRMS_10(rms) {
            if (!Number.isFinite(rms)) return RED_OOR;
            if (rms < RMS_MIN || rms > RMS_MAX) return RED_OOR;
            const t = (rms - RMS_MIN) / (RMS_MAX - RMS_MIN);
            const idx = Math.min(BINS - 1, Math.max(0, Math.floor(t * BINS)));
            return SCALE10[idx];
        }

        function fmtAWST(x) {
            const d = (x instanceof Date) ? x : new Date(x);
            const parts = new Intl.DateTimeFormat("en-AU", {
                timeZone: "Australia/Perth",
                year: "numeric", month: "2-digit", day: "2-digit",
                hour: "2-digit", minute: "2-digit", second: "2-digit",
                hour12: false
            }).formatToParts(d).reduce((acc, p) => { acc[p.type] = p.value; return acc; }, {});
            return `${parts.year}-${parts.month}-${parts.day} ${parts.hour}:${parts.minute}:${parts.second} AWST`;
        }

        let uploadedFilenames = [], sliderMin = 0, sliderMax = 0, sliderStartISO = null, sliderEndISO = null,
            selectedStationId = null, playTimer = null;
        const slider = document.getElementById('playbackSlider'),
              sliderLabel = document.getElementById('sliderLabel'),
              playBtn = document.getElementById('playBtn'),
              pauseBtn = document.getElementById('pauseBtn'),
              stationSelect = document.getElementById('stationSelect');

        // Initialize legend
        function renderLegend() {
            const root = document.getElementById('legendBins');
            root.innerHTML = '';
            for (let i = 0; i < SCALE10.length; i++) {
                const row = document.createElement('div');
                row.className = 'legend-row';
                const lo = RMS_MIN + i * (RMS_MAX - RMS_MIN) / BINS;
                const hi = RMS_MIN + (i + 1) * (RMS_MAX - RMS_MIN) / BINS;
                row.innerHTML = `<span class="sw" style="background:${SCALE10[i]}"></span>
                                <span>${lo.toFixed(1)}–${hi.toFixed(1)}</span>`;
                root.appendChild(row);
            }
        }

        function updateBadges(stations) {
            const wrap = document.getElementById('badgeList');
            wrap.innerHTML = '';
            stations.forEach(s => {
                const chip = document.createElement('button');
                chip.className = 'chip';
                const c = colorForRMS_10(s.rms);
                chip.style.borderColor = chip.style.color = c;
                chip.textContent = `${s.id} — ${s.rms.toFixed(1)}`;
                chip.onclick = () => {
                    selectedStationId = s.id;
                    stationSelect.value = s.id;
                    document.getElementById('selectedStation').textContent = s.id;
                    drawWave();
                };
                wrap.appendChild(chip);
            });
        }

        function updateSidePanelInfo() {
            document.getElementById('fileCount').textContent = uploadedFilenames.length || '—';
            if (sliderStartISO && sliderEndISO) {
                const start = new Date(sliderStartISO);
                const end = new Date(sliderEndISO);
                const duration = Math.round((end - start) / 1000 / 60); // minutes
                document.getElementById('timelineInfo').textContent = `${duration}min`;
            }
            document.getElementById('selectedStation').textContent = selectedStationId || '—';
        }

        document.getElementById('uploadForm').addEventListener('submit', async (e) => {
            e.preventDefault();

            const filesInput = document.getElementById('seedlink_files');
            const formData = new FormData();
            for (let i = 0; i < filesInput.files.length; i++) {
                formData.append('seedlink_file', filesInput.files[i]);
            }

            // Upload
            const res = await fetch('/playback', { method: 'POST', body: formData });
            const data = await res.json().catch(() => ({}));
            if (data.status !== 'uploaded') { alert('Upload failed'); return; }

            uploadedFilenames = Array.isArray(data.filenames)
                ? data.filenames
                : [data.filename].filter(Boolean);

            // Prepare timeline
            await initTimeline();

            // ---- Verify the new station JSON shape (timestamp, band/env lengths & values) ----
            try {
                const json = await fetchJSON(`/playback_json/${uploadedFilenames.join(',')}`);
                const q = document.getElementById('queryResult');
                const n = Array.isArray(json?.stations) ? json.stations.length : 0;
                q.innerHTML = `<b>Files:</b> ${uploadedFilenames.join(', ')}<br/>
                            <b>playback_json:</b> ${n} station object(s) received`;
                console.log('playback_json sample:', json);
            } catch (err) {
                document.getElementById('queryResult').innerHTML =
                'playback_json fetch failed';
            }

            // ---- Detect hour min/max RMS to seed the color scale (optional) ----
            try {
                const stats = await fetchJSON(`/playback_stats/${uploadedFilenames.join(',')}`);
                const vmin = stats?.min?.value, vmax = stats?.max?.value;
                const out = document.getElementById('queryResult');
                if (Number.isFinite(vmin) && Number.isFinite(vmax) && vmax > vmin) {
                out.innerHTML += `<br/><b>Detected Hour RMS Range</b><br/>
                    Min: ${vmin.toFixed(1)} @ <code>${stats.min.id}</code> (${fmtAWST(stats.min.iso)})<br/>
                    Max: ${vmax.toFixed(1)} @ <code>${stats.max.id}</code> (${fmtAWST(stats.max.iso)})`;
                const ok = window.confirm(
                    `Detected hour min/max RMS:\n\nmin = ${vmin.toFixed(1)}\nmax = ${vmax.toFixed(1)}\n\nUse this as the 10-bin color range?`
                );
                if (ok) setColorRange(vmin, vmax);
                } else {
                out.innerHTML += '<br/>Could not detect min/max RMS';
                }
            } catch {
                document.getElementById('queryResult').innerHTML += '<br/>Stats error';
            }

            // Initial render
            await refreshMap();
            await drawWave();
            setPlayingState(false);
            updateSidePanelInfo();
            renderLegend();
        });

        async function initTimeline() {
            const res = await fetch(`/playback_timeline/${uploadedFilenames.join(',')}`, { cache: 'no-store' });
            const t = await res.json();
            sliderStartISO = t.start_iso;
            sliderEndISO = t.end_iso;
            sliderMin = 0;
            sliderMax = Math.max(0, (t.steps ?? 1) - 1);
            slider.min = sliderMin;
            slider.max = sliderMax;
            slider.value = sliderMin;
            slider.disabled = false;
            updateSliderLabel();
            updateSidePanelInfo();
        }

        slider.addEventListener('input', async () => {
            updateSliderLabel();
            await refreshMap();
            await drawWave();
        });

        function updateSliderLabel() {
            if (!sliderStartISO || !sliderEndISO) { sliderLabel.textContent = ''; return; }
            const curISO = getSliderISO(Number(slider.value));
            sliderLabel.textContent = `${fmtAWST(sliderStartISO)} — ${fmtAWST(sliderEndISO)} | Current: ${fmtAWST(curISO)}`;
        }

        function getSliderISO(val) {
            const start = new Date(sliderStartISO).getTime();
            const end = new Date(sliderEndISO).getTime();
            const step = (end - start) / (sliderMax - sliderMin || 1);
            return new Date(start + (val - sliderMin) * step).toISOString();
        }

        let map = null, markers = [];
        function ensureMap() {
            if (map) return;
            map = L.map('seismicMap', { preferCanvas: true }).setView([-31.35, 115.92], 10);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { maxZoom: 18, attribution: '© OpenStreetMap' }).addTo(map);
        }

        function populateStationSelect(stations) {
            if (!stations || stations.length <= 1) { stationSelect.hidden = true; stationSelect.replaceChildren(); return; }
            stationSelect.hidden = false;
            stationSelect.replaceChildren(...stations.map(st => {
                const opt = document.createElement('option');
                opt.value = st.id;
                opt.textContent = st.id;
                return opt;
            }));
            if (!selectedStationId) selectedStationId = stations[0].id;
            stationSelect.value = selectedStationId;
            document.getElementById('selectedStation').textContent = selectedStationId;
        }

        async function refreshMap() {
            if (!uploadedFilenames.length) return;
            ensureMap();
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            const step = Number(slider.value);
            const data = await fetchJSON(`/playback_data/${uploadedFilenames.join(',')}/${step}`);
            const stations = Array.isArray(data.stations) ? data.stations : [];
            if (!selectedStationId && stations.length) selectedStationId = stations[0].id;
            populateStationSelect(stations);
            updateBadges(stations);

            stations.forEach(st => {
                const col = colorForRMS_10(st.rms);
                const m = L.circle([st.lat, st.lon], {
                    radius: 1000, color: '#222', weight: 2, fillColor: col, fillOpacity: 0.75
                }).addTo(map).bindPopup(
                    `<b>${st.id}</b><br>RMS: ${st.rms.toFixed(1)}<br>${fmtAWST(sliderStartISO)}`
                );
                m.on('click', async () => {
                    selectedStationId = st.id;
                    stationSelect.value = st.id;
                    document.getElementById('selectedStation').textContent = st.id;
                    await drawWave();
                });
                markers.push(m);
            });
        }

        stationSelect.addEventListener('change', async () => {
            selectedStationId = stationSelect.value;
            document.getElementById('selectedStation').textContent = selectedStationId;
            await drawWave();
        });

        async function drawWave() {
            if (!uploadedFilenames.length || !selectedStationId) return;
            const step = Number(slider.value);
            const url = `/playback_wave/${uploadedFilenames.join(',')}/${step}/${encodeURIComponent(selectedStationId)}`;
            const w = await fetchJSON(url);
            const fs = Number(w.fs || 0);
            const values = Array.isArray(w.values) ? w.values : [];
            const t0 = w.t0_iso ? new Date(w.t0_iso) : null;
            if (!values.length) {
                Plotly.react('wave', [], {
                    paper_bgcolor: '#111', plot_bgcolor: '#111',
                    margin: { l: 50, r: 10, t: 10, b: 40 },
                    xaxis: { gridcolor: '#333' }, yaxis: { gridcolor: '#333' }
                });
                return;
            }
            const dt = fs > 0 ? 1.0 / fs : 0.004;
            const xs = t0 ? values.map((_, i) => new Date(t0.getTime() + i * dt * 1000)) : values.map((_, i) => i);
            Plotly.react('wave', [{
                x: xs,
                y: values,
                type: 'scatter',
                mode: 'lines',
                name: selectedStationId
            }], {
                paper_bgcolor: '#111',
                plot_bgcolor: '#111',
                font: { color: '#eaeaea' },
                margin: { l: 50, r: 10, t: 10, b: 40 },
                xaxis: { title: 'time', gridcolor: '#333' },
                yaxis: { title: 'amplitude', gridcolor: '#333' },
                uirevision: 'keep'
            }, { responsive: true });
        }

        function setPlayingState(isPlaying) {
            playBtn.disabled = isPlaying || slider.disabled;
            pauseBtn.disabled = !isPlaying || slider.disabled;
            document.getElementById('playingStatus').textContent = isPlaying ? 'Playing' : 'Stopped';
        }

        async function stepOnce() {
            const next = Math.min(Number(slider.max), Number(slider.value) + 1);
            slider.value = next;
            updateSliderLabel();
            await refreshMap();
            await drawWave();
            if (next >= Number(slider.max)) stopPlaying();
        }

        function startPlaying(intervalMs = 1000) {
            if (playTimer || slider.disabled) return;
            setPlayingState(true);
            playTimer = setInterval(stepOnce, intervalMs);
        }

        function stopPlaying() {
            if (playTimer) clearInterval(playTimer);
            playTimer = null;
            setPlayingState(false);
        }

        playBtn.addEventListener('click', () => startPlaying(1000));
        pauseBtn.addEventListener('click', stopPlaying);

        async function fetchJSON(url) {
            const res = await fetch(url, { cache: 'no-store' });
            if (!res.ok) throw new Error('Request failed');
            return res.json();
        }

        // Initialize legend on page load
        renderLegend();
    </script>
</body>
</html>