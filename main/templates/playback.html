<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Seismographer Playback</title>
  <link rel="stylesheet" href="/static/css/global.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    body { background:#0f0f0f; color:#eaeaea; }
    .container { max-width: 1100px; margin: auto; padding: 1.5rem; }
    #seismicMap { width: 100%; height: 100%; background: #1a1a1a; }
    header { display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin-bottom:.75rem; }
    .chip{display:inline-block;border:1px solid #444;border-radius:999px;padding:.25rem .6rem;font-size:.9rem}
    .chip--muted{opacity:.75}
    .sep{opacity:.5}
    .overlay.dark{color:#ddd}
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1 style="margin:0;">Playback</h1>
      <span class="sep">|</span>
      <div class="chip chip--muted">Upload .mseed / .miniseed (multi-file supported)</div>
      <span class="sep">|</span>
      <a href="/" class="chip">Back to Live</a>
    </header>

    <form id="uploadForm" enctype="multipart/form-data" method="POST" style="margin:.75rem 0 1rem;">
      <input type="file" name="seedlink_file" id="seedlink_files" accept=".mseed,.seed,.dat,.miniseed" multiple required>
      <button id="uploadAndPlayBtn" type="submit" class="btn btn--primary">Upload & Play</button>
    </form>

    <!-- MAP -->
    <div id="mapWrap" class="container-main">
      <div id="seismicMap"></div>
      <div id="badges" class="overlay dark"></div>
    </div>

    <!-- CONTROLS: under the map, above the waveform -->
    <div id="controls">
      <div class="controls-row">
        <button id="playBtn" type="button" class="btn" disabled>▶ Play</button>
        <button id="pauseBtn" type="button" class="btn" disabled>⏸ Pause</button>
        <select id="stationSelect" class="station-select" hidden></select>
        <span id="sliderLabel" class="text-xs text-muted"></span>
      </div>
      <div class="slider-container">
        <label for="playbackSlider" class="slider-caption">Timeline:</label>
        <input type="range" id="playbackSlider" class="slider" min="0" max="0" value="0" disabled>
      </div>
    </div>

    <!-- WAVEFORM -->
    <div id="waveWrap" class="container-section">
      <div id="wave"></div>
    </div>
  </div>

  <!-- SINGLE script tag (the duplicate one caused the bug) -->
  <script>
  /* ---------- State ---------- */
  let uploadedFilenames = [];
  let sliderMin = 0, sliderMax = 0;
  let sliderStartISO = null, sliderEndISO = null;
  let selectedStationId = null;
  let playTimer = null;

  const slider = document.getElementById('playbackSlider');
  const sliderLabel = document.getElementById('sliderLabel');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stationSelect = document.getElementById('stationSelect');

  /* ---------- Upload ---------- */
  document.getElementById('uploadForm').addEventListener('submit', async (e) => {
    e.preventDefault();                                 // keep page here
    const filesInput = document.getElementById('seedlink_files');
    const formData = new FormData();
    for (let i = 0; i < filesInput.files.length; i++) formData.append('seedlink_file', filesInput.files[i]);

    const res = await fetch('/playback', { method: 'POST', body: formData });
    const data = await res.json().catch(()=>({}));
    if (data.status !== 'uploaded') { alert('Upload failed'); return; }

    uploadedFilenames = Array.isArray(data.filenames) ? data.filenames : [data.filename];

    await initTimeline();         // enables slider
    await refreshMap();           // sets first station + badges
    await drawWave();             // draws first frame

    setPlayingState(false);       // Play enabled, Pause disabled
  });

  /* ---------- Timeline ---------- */
  async function initTimeline() {
    const res = await fetch(`/playback_timeline/${uploadedFilenames.join(',')}`, { cache:'no-store' });
    const t = await res.json();
    sliderStartISO = t.start_iso;
    sliderEndISO   = t.end_iso;
    sliderMin = 0;
    sliderMax = Math.max(0, (t.steps ?? 1) - 1);

    slider.min = sliderMin;
    slider.max = sliderMax;
    slider.value = sliderMin;
    slider.disabled = false;

    updateSliderLabel();
  }

  slider.addEventListener('input', async () => {
    updateSliderLabel();
    await refreshMap();
    await drawWave();
  });

  function updateSliderLabel() {
    if (!sliderStartISO || !sliderEndISO) { sliderLabel.textContent = ''; return; }
    const curISO = getSliderISO(Number(slider.value));
    sliderLabel.textContent =
      `${new Date(sliderStartISO).toLocaleString()} — ${new Date(sliderEndISO).toLocaleString()} | Current: ${new Date(curISO).toLocaleString()}`;
  }

  function getSliderISO(val) {
    const start = new Date(sliderStartISO).getTime();
    const end   = new Date(sliderEndISO).getTime();
    const step  = (end - start) / (sliderMax - sliderMin || 1);
    return new Date(start + (val - sliderMin) * step).toISOString();
  }

  /* ---------- Map ---------- */
  let map = null;
  let markers = [];

  function ensureMap() {
    if (map) return;
    map = L.map('seismicMap', { preferCanvas: true }).setView([-31.35, 115.92], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                { maxZoom: 18, attribution: '© OpenStreetMap' }).addTo(map);
  }

  function colorForRMS(rms){
    const LEVELS=[100,300,500,800,1200], COLORS=['#e31a1c','#33a02c','#1f78b4','#ffcc00','#ff7f00'];
    let idx=0,d=Infinity; for (let i=0;i<LEVELS.length;i++){ const di=Math.abs((rms||0)-LEVELS[i]); if(di<d){d=di;idx=i;} }
    return COLORS[idx];
  }

  function populateStationSelect(stations) {
    if (!stations || stations.length <= 1) {
      stationSelect.hidden = true; stationSelect.replaceChildren(); return;
    }
    stationSelect.hidden = false;
    stationSelect.replaceChildren(...stations.map(st => {
      const opt = document.createElement('option'); opt.value = st.id; opt.textContent = st.id; return opt;
    }));
    if (!selectedStationId) selectedStationId = stations[0].id;
    stationSelect.value = selectedStationId;
  }

  async function refreshMap() {
    if (!uploadedFilenames.length) return;
    ensureMap();

    // clear previous markers
    markers.forEach(m => map.removeLayer(m)); markers = [];

    const step = Number(slider.value);
    const data = await fetchJSON(`/playback_data/${uploadedFilenames.join(',')}/${step}`);
    const stations = Array.isArray(data.stations) ? data.stations : [];

    if (!selectedStationId && stations.length) selectedStationId = stations[0].id;
    populateStationSelect(stations);

    stations.forEach(st => {
      const col = colorForRMS(st.rms);
      const m = L.circleMarker([st.lat, st.lon], { radius: 10, color: col, fillColor: col, fillOpacity: 0.85 })
        .addTo(map).bindPopup(`<b>${st.id}</b><br>RMS: ${st.rms.toFixed(2)}`);
      m.on('click', async () => { selectedStationId = st.id; stationSelect.value = st.id; await drawWave(); });
      markers.push(m);
    });

    // badges
    const badges = document.getElementById('badges');
    badges.innerHTML = stations.map(st =>
      `<span class="chip" style="border-color:${colorForRMS(st.rms)};color:${colorForRMS(st.rms)}">${st.id}: <b>${st.rms.toFixed(2)}</b></span>`
    ).join(' ');
  }

  stationSelect.addEventListener('change', async () => {
    selectedStationId = stationSelect.value; await drawWave();
  });

  /* ---------- Waveform ---------- */
  async function drawWave() {
    if (!uploadedFilenames.length || !selectedStationId) return;

    const step = Number(slider.value);
    const url = `/playback_wave/${uploadedFilenames.join(',')}/${step}/${encodeURIComponent(selectedStationId)}`;

    const w = await fetchJSON(url);
    const fs = Number(w.fs || 0);
    const values = Array.isArray(w.values) ? w.values : [];
    const t0 = w.t0_iso ? new Date(w.t0_iso) : null;

    if (!values.length) {
      Plotly.react('wave', [], {
        paper_bgcolor:'#111', plot_bgcolor:'#111',
        margin:{l:50,r:10,t:10,b:40}, xaxis:{gridcolor:'#333'}, yaxis:{gridcolor:'#333'}
      });
      return;
    }
    const dt = fs > 0 ? 1.0 / fs : 0.004;
    const xs = t0 ? values.map((_, i) => new Date(t0.getTime() + i * dt * 1000)) : values.map((_, i) => i);

    Plotly.react('wave',
      [{ x: xs, y: values, type: 'scatter', mode: 'lines', name: selectedStationId }],
      {
        paper_bgcolor:'#111', plot_bgcolor:'#111', font:{color:'#eaeaea'},
        margin:{l:50,r:10,t:10,b:40},
        xaxis:{title:'time', gridcolor:'#333'},
        yaxis:{title:'amplitude', gridcolor:'#333'},
        uirevision:'keep'
      },
      { responsive:true }
    );
  }

  /* ---------- Play / Pause (1 step/second) ---------- */
  function setPlayingState(isPlaying) {
    playBtn.disabled  = isPlaying || slider.disabled;
    pauseBtn.disabled = !isPlaying || slider.disabled;
  }

  async function stepOnce() {
    const next = Math.min(Number(slider.max), Number(slider.value) + 1);
    slider.value = next;
    updateSliderLabel();
    await refreshMap();
    await drawWave();
    if (next >= Number(slider.max)) stopPlaying();
  }

  function startPlaying(intervalMs = 1000) { // 1 Hz
    if (playTimer || slider.disabled) return;
    setPlayingState(true);
    playTimer = setInterval(stepOnce, intervalMs);
  }

  function stopPlaying() {
    if (playTimer) clearInterval(playTimer);
    playTimer = null;
    setPlayingState(false);
  }

  playBtn.addEventListener('click', () => startPlaying(1000));
  pauseBtn.addEventListener('click', stopPlaying);

  /* ---------- Utils ---------- */
  async function fetchJSON(url){
    const res = await fetch(url, { cache:'no-store' });
    if (!res.ok) throw new Error('Request failed');
    return res.json();
  }
  </script>
</body>
</html>
